---
layout: post
title:  "Git merge without pain"
date:   2018-11-06 19:54:00 +0300
categories: git rebase commit merge
---
Все мы сталкивались с болью, которая возникает при разрешении конфликтов 
remote и локальной ветки. Кто-то пользуется `git merge`, другие используют
`git rebase`, но такая проблема время от времени все равно возникает и у тех, 
и у других.

Я хочу рассказать о том, что я делаю, чтобы минимизировать время, потраченное
на решение конфликтов.

## Проблемы больших pull request-ов

Одна из самых частых причин сложных merge-й — большая разница между ветками. 
Можно, конечно, посоветовать не допускать больших расхождений, но, к сожалению,
это не всегда зависит лишь от самого разработчика. Может быть, что он сделал свою
работу, не успел пройти code review, и его тут же попросили переключиться на другую
задачу. Когда же он вернулся к своей предыдущей задаче, отличия между master-ом
и его веткой были уже слишком большими...

Тем не менее, можно избежать конфликтов даже если накопилось очень много изменений
репозитория. Важно понимать, что причиной сложных merge-й является не количество
commit-ов, но их содержание, порядок и способ слияния.

## Пример возникновения конфликта при рефакторинге

Пусть у Компании был пакет *foo* с единственным модулем `foo.py`:

{% highlight python %}
def add(a, b):
    return a + b
{% endhighlight %}

Заказчик, который использует код Компании попросил добавить новую функциональность — 
функцию `subtract`, которая должна выполнять сложную бизнес задачу. В то же время 
тимлид решил, что проект начинает разрастаться и поставил еще одну задачу — 
отрефакторить скрипт. 

В команде как раз было 2 свободных разработчика - Петя и Вася. Компания использовала
*git*, так что оба разрабочика начали работать, как только распределили задачи. Разработчик 
Петя начал писать функцию `subtract`, а разработчик Вася начал рефакторить модуль `foo.py`.

Петя закончил первым, он добавил функцию `subtract` в файл `foo.py`:

{% highlight python %}
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b
{% endhighlight %}

Петя прошел code review и радостно залил свой код в master. 

Вася тоже закончил работу, он создал пакет `foo` и переместил весь код из `foo.py`
в `foo/math.py`.

`foo/__init__.py`:

{% highlight python %}
from math import add

__all__ = [
  'add',
]
{% endhighlight %}

`foo/math.py`:

{% highlight python %}
"""Math module"""

def add(a, b):
    return a + b
{% endhighlight %}

Чтобы Васе теперь залить код в master, ему нужно сначала взять свежий master и 
обновить свою ветку.


## git rebase учитывает историю перемещений файлов
